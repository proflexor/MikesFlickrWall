package mma.custom.effect{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.GradientType;	import flash.display.Graphics;	import flash.display.Sprite;	import flash.events.Event;	import flash.filters.DisplacementMapFilter;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;		public class Ripple extends Sprite {		//change these values		public var radius : int = 140;		public var durationInFrames : int = 70;		public var amplitude : int = 15;		public var waveSprite : Sprite;				public var offsets:Array = [new Point(), new Point()]; 		///		private static const GREY : int = 0x808080;		private var displayObject : DisplayObject;		private var bitmapData : BitmapData;		private var bitmap : Bitmap;		private var displacementMapFilter : DisplacementMapFilter;		private var position : Point;		private var currentStep:int;		private var scale : Number; 		private var currentAmplitude : Number ;		private var matrix:Matrix;		private var rect:Rectangle;		private var filterIndex:int;		private var myFilters:Array;		private static var uniqueColorForReference:uint = 5;		private  var myColorRef:uint;		public function Ripple(_displayObject:DisplayObject) {			//make wave shape			waveSprite = createDisplacementMap();			displayObject = _displayObject;			matrix  = new Matrix(1, 0, 0, 1, 1, 1);			// prepare displacement bitmap			bitmapData = new BitmapData(radius * 2, radius * 2, false, GREY);			rect =  new Rectangle(0, 0, radius * 2, radius * 2)			bitmapData.fillRect(rect, GREY);			position = new Point();		}		public function rippleIt(loc:Point) : void {			position.x = loc.x - radius;			position.y = loc.y - radius;			displacementMapFilter = new DisplacementMapFilter(bitmapData, position, 1, 2, amplitude, amplitude);			//uniqueColorForReference is used just to which filter index is this ripple			// so we update right one!			displacementMapFilter.color = uniqueColorForReference;			myColorRef = uniqueColorForReference;			uniqueColorForReference++;			//add filter			myFilters = displayObject.filters	;			myFilters.push(displacementMapFilter);			displayObject.filters = myFilters;			currentStep = 0 ;			displayObject.addEventListener(Event.ENTER_FRAME,updateRipple );				}		private function updateRipple(event : Event) : void {					// scale down the  amplitude			currentAmplitude  = amplitude * ((durationInFrames - currentStep) / durationInFrames);			//get current index of filter			 myFilters = displayObject.filters ;			filterIndex = getFilterIndex();			if (currentAmplitude>0)			{				// scale up the ripple size				scale = (currentStep / durationInFrames);				matrix.a = scale;				matrix.d = scale;				matrix.tx = radius;				matrix.ty = radius;				// reset displacement bitmap 				bitmapData.fillRect(rect, GREY);				bitmapData.draw(waveSprite, matrix)	;											//apply // scale down the  amplitude				displacementMapFilter.scaleX = currentAmplitude;				displacementMapFilter.scaleY = currentAmplitude;				///just change this filter ref				myFilters[filterIndex] = displacementMapFilter;				displayObject.filters = myFilters;			}			else			{				//ripple is over				rippleComplete();			}			currentStep++;		}		private function rippleComplete (event:Event = null):void		{					//remove JUST this filter from displayObject.filters					var e:Event = new Event("RippleCompleted"); 			dispatchEvent(e); 					myFilters.splice(filterIndex, 1);			displayObject.filters = myFilters;				displayObject.removeEventListener(Event.ENTER_FRAME,updateRipple );							}		private function getFilterIndex():int		{			var ln:int = myFilters.length;			if (ln == 0) return -1;			for (var i :int = 0; i < ln; i++)			{				if (myFilters[i].color == myColorRef) return i;			}			trace("ERROR: FILTER IS NOT IN ARRAY");			return -1;		}				private function createDisplacementMap() : Sprite {			//x displacement			var redShape  : Sprite = new Sprite();			var graphics : Graphics = redShape.graphics;			graphics.clear();			graphics.beginGradientFill(GradientType.LINEAR, [0xFF0000, 0x000000], [1, 1], [0, 255])			graphics.drawCircle(0, 0, radius);							graphics.endFill();					//y displacement			var greenShape : Sprite = new Sprite();			graphics = greenShape.graphics;			graphics.clear();			graphics.beginGradientFill(GradientType.LINEAR, [0x00ff00,0x000000], [1,1],[0,255])			graphics.drawCircle(0, 0, radius);				graphics.endFill();						//create a "mask" to reveal the ring shape			var gradientMatrix:Matrix  = new Matrix(1, 0, 0, 1, 1, 1);			gradientMatrix.createGradientBox(radius*2,radius*2,0,-radius,-radius)			var addShape : Sprite = new Sprite();			graphics = addShape.graphics;			graphics.clear();			graphics.beginGradientFill(GradientType.RADIAL, [GREY,GREY,GREY], [1,0,1],[128,192,255],gradientMatrix)				graphics.drawCircle(0, 0, radius);			graphics.endFill();			//create the grey base			var bgShape : Sprite = new Sprite();			graphics  = bgShape.graphics;			graphics.clear();			graphics.beginFill(GREY);			graphics.drawRect(-radius,-radius,radius*2,radius*2)			graphics.endFill()			//put it all together			bgShape.addChild(redShape)			greenShape.rotation=90			greenShape.blendMode =BlendMode.ADD			redShape.addChild(greenShape)			redShape.addChild(addShape)			return bgShape;		}	}}